# Implementation Plan: Bandcamp Collection Manager

**Branch**: `007-bandcamp-collection-manager` | **Date**: 2026-01-31 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `kitty-specs/007-bandcamp-collection-manager/spec.md`

## Summary

Add a `bandcamp` CLI subcommand group that integrates with the user's Bandcamp purchase collection. The feature provides authentication (cookie extraction from browsers, manual config, mini-browser login), collection sync to a dedicated SQLite table, fuzzy matching against the local library at release and track level, download of owned content in specified formats, an HTML report with auto-refreshing download links via a local server, and a semi-automatic repair workflow that cross-references `files check` reports with Bandcamp matches using a Rich TUI for selection.

The implementation uses Bandcamp's undocumented `/api/fancollection/1/collection_items` endpoint for collection access, resolves download URLs through redownload page scraping, and stores collection data in dedicated SQLAlchemy tables within the existing cache database.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Click (CLI), SQLAlchemy 2.0 (ORM), Rich (TUI/output), requests (HTTP), rapidfuzz (matching), rookiepy (cookie extraction), beautifulsoup4 (HTML parsing)
**Storage**: SQLite (`.music-commander-cache.db`) — dedicated tables for Bandcamp data; JSON credentials file at `~/.config/music-commander/bandcamp-credentials.json`
**Testing**: pytest (unit + integration)
**Target Platform**: Linux
**Project Type**: Single project (extending existing CLI tool)
**Performance Goals**: Handle 1000+ purchases without degradation; collection sync should stream results incrementally
**Constraints**: No external services beyond Bandcamp; must work offline after initial sync for matching operations; headless environments must gracefully degrade (no mini-browser login)
**Scale/Scope**: Collections up to 5000+ purchases; fuzzy matching across 100k+ local tracks

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Gate | Status | Notes |
|------|--------|-------|
| Python 3.13+ | PASS | All new code uses 3.13+ features and type hints |
| Click for CLI | PASS | `bandcamp` group follows existing `files` group pattern |
| SQLAlchemy for DB | PASS | New models use SQLAlchemy 2.0 Mapped syntax |
| Rich for output | PASS | TUI, progress bars, tables all via Rich |
| Nix flake packaging | PASS | New deps (requests, rapidfuzz, rookiepy, beautifulsoup4) added to flake.nix and pyproject.toml |
| Tests for CLI commands | PASS | Unit tests for each subcommand and utility module planned |
| Tests for utility modules | PASS | Matching, parsing, cookie extraction all tested |
| 100k+ track performance | PASS | Fuzzy matching uses rapidfuzz (C++ backend); batch operations |
| No external services required | PASS | All Bandcamp interaction is user-initiated; offline matching works from cache |
| Works without Mixxx | PASS | Feature is independent of Mixxx |

**Post-design re-check**: All gates still pass. New dependencies are pure Python or have C extensions compatible with Nix packaging.

## Project Structure

### Documentation (this feature)

```
kitty-specs/007-bandcamp-collection-manager/
├── plan.md              # This file
├── research.md          # Phase 0: Bandcamp API research, auth strategy, matching approach
├── data-model.md        # Phase 1: SQLAlchemy models, credentials schema, config extension
├── spec.md              # Feature specification
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
music_commander/
├── commands/
│   └── bandcamp/
│       ├── __init__.py      # Click group "bandcamp" + shared options/constants
│       ├── auth.py          # Auth subcommand (cookie extraction, mini-browser, validation)
│       ├── sync.py          # Collection sync subcommand
│       ├── match.py         # Fuzzy matching subcommand
│       ├── download.py      # Download subcommand
│       ├── report.py        # HTML report generation + local server
│       └── repair.py        # Repair workflow (check report → match → TUI → download)
├── bandcamp/
│   ├── __init__.py
│   ├── client.py            # HTTP client for Bandcamp API (collection, redownload pages)
│   ├── parser.py            # HTML/JSON extraction from Bandcamp pages
│   ├── cookies.py           # Cookie extraction (rookiepy, manual, mini-browser)
│   ├── credentials.py       # Credentials file read/write
│   ├── matcher.py           # Fuzzy matching engine (rapidfuzz)
│   └── downloader.py        # File download logic (format resolution, progress)
├── cache/
│   ├── models.py            # Add BandcampRelease, BandcampTrack, BandcampReleaseFormat, BandcampSyncState
│   └── session.py           # Existing (no changes needed — tables auto-created)
├── config.py                # Add [bandcamp] section parsing
└── exceptions.py            # Add BandcampError, BandcampAuthError, BandcampParseError

tests/
├── unit/
│   ├── test_bandcamp_client.py
│   ├── test_bandcamp_parser.py
│   ├── test_bandcamp_matcher.py
│   ├── test_bandcamp_cookies.py
│   └── test_bandcamp_credentials.py
└── integration/
    ├── test_bandcamp_auth.py
    ├── test_bandcamp_sync.py
    ├── test_bandcamp_match.py
    └── test_bandcamp_repair.py
```

**Structure Decision**: Following the existing pattern where `commands/files/` is a package with subcommand modules, the bandcamp feature creates `commands/bandcamp/` as a Click group package. Business logic lives in a separate `bandcamp/` package under `music_commander/` to keep command handlers thin and logic testable independently.

## Parallel Work Analysis

### Dependency Graph

```
Foundation (WP01: models + config + credentials + exceptions)
    │
    ├── WP02: Auth (cookies, validation) ──────────────────┐
    │                                                       │
    ├── WP03: Client + Parser (HTTP, page extraction) ─────┤
    │                                                       │
    │   WP04: Matcher (fuzzy matching engine) ──────────────┤
    │                                                       │
    └───────────────────────────────────────────────────────┘
                            │
                ┌───────────┼───────────┐
                │           │           │
         WP05: Sync    WP06: Match   WP07: Download
         (CLI cmd)     (CLI cmd)     (CLI cmd + downloader)
                │           │           │
                └───────────┼───────────┘
                            │
                    ┌───────┴───────┐
                    │               │
              WP08: Report    WP09: Repair
              (HTML + server) (TUI + check integration)
```

### Work Distribution

- **Sequential (foundation)**: WP01 must complete first — all other work packages depend on models, config, and credentials
- **Parallel wave 1**: WP02, WP03, WP04 can proceed in parallel after WP01
- **Parallel wave 2**: WP05, WP06, WP07 can proceed after their respective dependencies
- **Final wave**: WP08 and WP09 depend on sync, match, and download being available

### Coordination Points

- **After WP01**: Verify models create correctly in SQLite, config loads with new section
- **After WP02+WP03**: Verify authenticated requests work end-to-end
- **After WP05+WP06+WP07**: Integration test of full sync → match → download flow
- **After WP08+WP09**: Full feature integration test
